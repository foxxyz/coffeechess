// Generated by CoffeeScript 1.7.1
(function() {
  var AIPlayer, Bishop, Chess, HumanPlayer, King, Knight, Pawn, Piece, Player, Queen, Rook, em_value, enableDrag, game, pieces,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  em_value = 64;

  game = null;

  Player = (function() {
    function Player(game, color) {
      this.game = game;
      this.color = color;
      this.dom_object = $("#" + this.color);
    }

    Player.prototype.draw = function() {
      if (this.game.player.color === this.color) {
        return this.dom_object.addClass("active").siblings().removeClass("active");
      }
    };

    Player.prototype.make_move = function() {};

    return Player;

  })();

  HumanPlayer = (function(_super) {
    __extends(HumanPlayer, _super);

    function HumanPlayer() {
      return HumanPlayer.__super__.constructor.apply(this, arguments);
    }

    HumanPlayer.prototype.make_move = function() {};

    return HumanPlayer;

  })(Player);

  AIPlayer = (function(_super) {
    __extends(AIPlayer, _super);

    function AIPlayer() {
      return AIPlayer.__super__.constructor.apply(this, arguments);
    }

    AIPlayer.prototype.auto_move = function() {
      var moves, pieces;
      pieces = this.dom_object.children(':not(:animated)');
      moves = $("#possible_moves");
      while (!(moves.children().length || !this.game.active)) {
        pieces.eq(Math.floor(Math.random() * pieces.length)).trigger('click');
      }
      moves = moves.children();
      if (!moves.length || !this.game.active) {
        return;
      }
      return moves.eq(Math.floor(Math.random() * moves.length)).trigger('click');
    };

    AIPlayer.prototype.make_move = function() {
      if (this.game.promotion) {
        $(".promotion span").eq(Math.floor(Math.random() * 4)).trigger('click');
      }
      return setTimeout((function(_this) {
        return function() {
          return _this.auto_move();
        };
      })(this), 1000);
    };

    return AIPlayer;

  })(Player);

  window.Chess = Chess = (function() {
    function Chess(dom, players, board) {
      var color, player, _ref;
      this.dom = dom;
      this.players = players;
      this.board = board;
      this.moves = [];
      this.en_passant = false;
      this.promotion = false;
      this.orientation = {
        x: 0,
        y: 0,
        z: 0
      };
      this.active = false;
      this.player = null;
      this.in_check = false;
      this.in_draw = false;
      _ref = this.players;
      for (color in _ref) {
        player = _ref[color];
        this.players[color] = new player(this, color);
      }
      this.board = this.set_up(this.board);
      this.draw();
    }

    Chess.prototype.add = function(piece) {
      return this.board[piece.x][piece.y] = piece;
    };

    Chess.prototype.animate = function(x, y, z) {
      this.dom.addClass('transition');
      setTimeout((function(_this) {
        return function() {
          return _this.dom.removeClass('transition');
        };
      })(this), 2000);
      this.orientation = {
        x: x,
        y: y,
        z: z
      };
      return this.draw();
    };

    Chess.prototype.check_exists = function(with_piece, at_position) {
      var current_position, in_check, piece, piece_at_new_position, position, under_attack, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      in_check = [];
      if ((with_piece != null) && (at_position != null)) {
        piece_at_new_position = this.board[at_position.x][at_position.y];
        this.remove(with_piece);
        current_position = {
          x: with_piece.x,
          y: with_piece.y
        };
        _ref = [at_position.x, at_position.y], with_piece.x = _ref[0], with_piece.y = _ref[1];
        this.add(with_piece);
      }
      _ref1 = this.pieces();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        piece = _ref1[_i];
        _ref2 = piece.possible_moves(false);
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          position = _ref2[_j];
          under_attack = this.piece(position);
          if (under_attack instanceof King) {
            in_check.push(under_attack.color);
          }
        }
      }
      if ((with_piece != null) && (at_position != null)) {
        _ref3 = [current_position.x, current_position.y], with_piece.x = _ref3[0], with_piece.y = _ref3[1];
        this.board[at_position.x][at_position.y] = piece_at_new_position;
        this.add(with_piece);
      }
      return in_check;
    };

    Chess.prototype.draw_exists = function() {
      var active_pieces, black_pieces, piece, white_pieces;
      active_pieces = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pieces();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          piece = _ref[_i];
          if (piece.possible_moves().length > 0 && piece.color === this.player.color) {
            _results.push(piece);
          }
        }
        return _results;
      }).call(this);
      if (active_pieces.length < 1) {
        return true;
      }
      white_pieces = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pieces();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          piece = _ref[_i];
          if (piece.color === 'white') {
            _results.push(piece);
          }
        }
        return _results;
      }).call(this);
      black_pieces = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pieces();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          piece = _ref[_i];
          if (piece.color === 'black') {
            _results.push(piece);
          }
        }
        return _results;
      }).call(this);
      if (white_pieces.length < 2 && black_pieces.length < 2) {
        return true;
      }
    };

    Chess.prototype.draw = function() {
      var color, player, _ref;
      _ref = this.players;
      for (color in _ref) {
        player = _ref[color];
        player.draw();
      }
      if (this.in_check.length) {
        this.dom.addClass("in_check");
      } else {
        this.dom.removeClass("in_check");
      }
      if (this.in_check.length && !this.active) {
        this.dom.addClass("mate");
      } else {
        this.dom.removeClass("mate");
      }
      if (this.in_draw) {
        this.dom.addClass('draw');
      } else {
        this.dom.removeClass("draw");
      }
      this.dom.css({
        '-webkit-transform': 'rotateX(' + this.orientation.x + 'deg) rotateZ(' + this.orientation.z + 'deg) rotateY(' + this.orientation.y + 'deg)',
        '-moz-transform': 'rotateX(' + this.orientation.x + 'deg) rotateZ(' + this.orientation.z + 'deg) rotateY(' + this.orientation.y + 'deg)',
        'transform': 'rotateX(' + this.orientation.x + 'deg) rotateZ(' + this.orientation.z + 'deg) rotateY(' + this.orientation.y + 'deg)'
      });
      if (Math.abs(this.orientation.x) > 50 && Math.abs(this.orientation.x) < 310) {
        return $("#pieces span, #possible_moves").addClass("upright");
      } else {
        return $("#pieces span, #possible_moves").removeClass("upright");
      }
    };

    Chess.prototype.end_turn = function() {
      var active_pieces, piece;
      this.in_check = this.check_exists();
      this.in_draw = this.draw_exists();
      if (this.in_check.length) {
        active_pieces = (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.pieces();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            piece = _ref[_i];
            if (piece.possible_moves().length > 0 && (_ref1 = piece.color, __indexOf.call(this.in_check, _ref1) >= 0)) {
              _results.push(piece);
            }
          }
          return _results;
        }).call(this);
        this.active = active_pieces.length !== 0;
      } else if (this.in_draw) {
        this.active = false;
      }
      this.draw();
      return this.player.make_move();
    };

    Chess.prototype.invalid = function(position) {
      return position.x < 0 || position.y < 0 || position.x >= this.board.length || position.y >= this.board.length;
    };

    Chess.prototype.next_turn = function() {
      this.player = this.player && this.player.color === 'white' ? this.players.black : this.players.white;
      return this.end_turn();
    };

    Chess.prototype.piece = function(position) {
      if (this.en_passant && this.en_passant.position.x === position.x && this.en_passant.position.y === position.y) {
        return this.en_passant.piece;
      }
      return this.board[position.x][position.y];
    };

    Chess.prototype.pieces = function() {
      var col, pieces, square, _i, _j, _len, _len1, _ref;
      pieces = [];
      _ref = this.board;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        for (_j = 0, _len1 = col.length; _j < _len1; _j++) {
          square = col[_j];
          if (square) {
            pieces.push(square);
          }
        }
      }
      return pieces;
    };

    Chess.prototype.promote = function(pawn) {
      $(".promotion").show();
      $(".promotion span").on("click", function(e) {
        $(this).parent().fadeOut().find("span").off();
        return pawn.promote(pieces[$(this).attr("class")]);
      });
      this.promotion = true;
      return this.player.make_move();
    };

    Chess.prototype.record = function(piece, new_position) {
      console.log(piece["class"]() + " from " + piece.x + "," + piece.y + " to " + new_position.x + "," + new_position.y);
      return this.moves.push([
        piece, {
          x: piece.x,
          y: piece.y
        }, new_position
      ]);
    };

    Chess.prototype.remove = function(piece) {
      return this.board[piece.x][piece.y] = null;
    };

    Chess.prototype.set_up = function(fen_string) {
      var board, board_string, char, color, piece, piece_dom, player, x, y, _i, _len, _ref, _ref1;
      if (fen_string == null) {
        fen_string = "RNBQKBNR/PPPPPPPP/////pppppppp/rnbqkbnr";
      }
      board = (function() {
        var _i, _results;
        _results = [];
        for (x = _i = 0; _i <= 7; x = ++_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (y = _j = 0; _j <= 7; y = ++_j) {
              _results1.push(null);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      if (fen_string == null) {
        board;
      }
      $('#pieces #white span').off().parent().empty();
      $('#pieces #black span').off().parent().empty();
      _ref = fen_string.split(" "), board_string = _ref[0], player = _ref[1];
      _ref1 = [0, 0], x = _ref1[0], y = _ref1[1];
      for (_i = 0, _len = board_string.length; _i < _len; _i++) {
        char = board_string[_i];
        piece = null;
        switch (char.toLowerCase()) {
          case "b":
            piece = Bishop;
            break;
          case "k":
            piece = King;
            break;
          case "n":
            piece = Knight;
            break;
          case "p":
            piece = Pawn;
            break;
          case "q":
            piece = Queen;
            break;
          case "r":
            piece = Rook;
            break;
          case "/":
            y += 1;
            x = 0;
            break;
          default:
            x += parseInt(char);
        }
        if (piece == null) {
          continue;
        }
        color = char.charCodeAt() < 90 ? "black" : "white";
        piece_dom = $('<span></span>');
        $("#pieces #" + color).append(piece_dom);
        board[x][y] = new piece(piece_dom, this, color, {
          "x": x,
          "y": y
        });
        x += 1;
      }
      this.player = player === "w" ? this.players.white : this.players.black;
      return board;
    };

    Chess.prototype.start = function() {
      this.active = true;
      return this.next_turn();
    };

    Chess.prototype.under_attack = function(position) {
      return false;
    };

    return Chess;

  })();

  Piece = (function() {
    function Piece(dom_object, game, color, position, parent) {
      this.dom_object = dom_object;
      this.game = game;
      this.color = color;
      this.parent = parent;
      if (position) {
        this.x = position.x;
        this.y = position.y;
      } else {
        this.get_position(this.dom_object);
      }
      this.direction = this.color === 'black' ? 1 : -1;
      this.dom_object.addClass(this["class"]()).html(this.html());
      if (this.parent && this.dom_object) {
        this.dom_object.on("click", $.proxy(this.parent.make_move, this.parent, position));
      } else if (this.dom_object) {
        this.dom_object.on("click", $.proxy(this.select, this));
      }
      this.touched = false;
      this.draw();
    }

    Piece.prototype["class"] = function() {
      return this.constructor.name.toLowerCase();
    };

    Piece.prototype.deselect = function() {
      $('#pieces span').removeClass("selected");
      $("#possible_moves").empty();
      return this.game.next_turn();
    };

    Piece.prototype.draw = function(fluid) {
      if (fluid) {
        return this.dom_object.animate({
          left: this.x + "em",
          top: this.y + "em"
        });
      } else {
        return this.dom_object.css({
          left: this.x + "em",
          top: this.y + "em"
        });
      }
    };

    Piece.prototype.get_position = function(dom_object) {
      if (this.dom_object.css("left").indexOf("em") !== -1) {
        this.x = Math.round(this.dom_object.css("left").replace(/em/, ""));
        this.y = Math.round(this.dom_object.css("top").replace(/em/, ""));
      } else {
        this.x = Math.round(this.dom_object.css("left").replace(/px/, "") / em_value);
        this.y = Math.round(this.dom_object.css("top").replace(/px/, "") / em_value);
      }
      return this.draw();
    };

    Piece.prototype.html = function() {
      return this.constructor.html_code;
    };

    Piece.prototype.make_move = function(position) {
      this.move(position);
      this.post_move();
      this.game.draw();
      if (!this.game.promotion) {
        return this.deselect();
      }
    };

    Piece.prototype.move = function(position) {
      var captured, rook_position, _ref;
      this.game.remove(this);
      this.game.record(this, position);
      _ref = [position.x, position.y], this.x = _ref[0], this.y = _ref[1];
      if (position.capture) {
        captured = this.game.piece(position);
        captured.dom_object.fadeOut(function() {
          return this.remove();
        });
        this.game.remove(captured);
      }
      if (position.castle) {
        rook_position = {
          x: 4 + ((4 - position.x) / -2),
          y: position.y
        };
        position.castle.move(rook_position);
      }
      this.game.en_passant = position.en_passant ? {
        piece: this,
        position: position.en_passant
      } : false;
      this.game.add(this);
      this.touched = true;
      return this.draw(true);
    };

    Piece.prototype.position = function() {
      return {
        x: this.x,
        y: this.y
      };
    };

    Piece.prototype.possible_moves = function(filter_checks) {
      var move, moves, n, pos, position, _i, _j, _len, _ref, _ref1;
      if (filter_checks == null) {
        filter_checks = true;
      }
      moves = [];
      _ref = this.constructor.move_matrix;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        for (n = _j = 1, _ref1 = this.constructor.range; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; n = 1 <= _ref1 ? ++_j : --_j) {
          position = {
            x: this.x + pos[0] * n,
            y: this.y + pos[1] * n
          };
          if (this.game.invalid(position)) {
            break;
          }
          if (this.game.piece(position)) {
            if (this.game.piece(position).color !== this.color) {
              position.capture = true;
              moves.push(position);
            }
            break;
          }
          moves.push(position);
        }
      }
      if (filter_checks) {
        moves = (function() {
          var _k, _len1, _ref2, _results;
          _results = [];
          for (_k = 0, _len1 = moves.length; _k < _len1; _k++) {
            move = moves[_k];
            if (_ref2 = this.color, __indexOf.call(this.game.check_exists(this, move), _ref2) < 0) {
              _results.push(move);
            }
          }
          return _results;
        }).call(this);
      }
      return moves;
    };

    Piece.prototype.post_move = function() {};

    Piece.prototype.select = function() {
      var ghost, ghost_dom, move, _i, _len, _ref, _results;
      if (this.color !== this.game.player.color || !this.game.active) {
        return;
      }
      $('#pieces span').removeClass("selected");
      this.dom_object.addClass("selected");
      $("#possible_moves").empty();
      _ref = this.possible_moves();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        move = _ref[_i];
        ghost_dom = this.dom_object.clone().removeClass();
        ghost = new this.constructor(ghost_dom, this.game, this.color, move, this);
        ghost.draw();
        if (move.capture) {
          ghost_dom.text("").addClass("capture");
        }
        _results.push($("#possible_moves").append(ghost_dom));
      }
      return _results;
    };

    return Piece;

  })();

  Pawn = (function(_super) {
    __extends(Pawn, _super);

    function Pawn() {
      return Pawn.__super__.constructor.apply(this, arguments);
    }

    Pawn.html_code = "&#9823";

    Pawn.prototype.possible_moves = function(filter_checks) {
      var capture_matrix, move, move_matrix, moves, pos, position, _i, _j, _len, _len1;
      if (filter_checks == null) {
        filter_checks = true;
      }
      moves = [];
      move_matrix = [[0, this.direction]];
      capture_matrix = [[-1, this.direction], [1, this.direction]];
      if (this.y === 3.5 - 2.5 * this.direction) {
        move_matrix.push([0, this.direction * 2]);
      }
      for (_i = 0, _len = move_matrix.length; _i < _len; _i++) {
        pos = move_matrix[_i];
        position = {
          x: this.x + pos[0],
          y: this.y + pos[1]
        };
        if (Math.abs(pos[1]) === 2) {
          position.en_passant = {
            x: this.x,
            y: this.y + pos[1] / 2,
            'capture': true
          };
        }
        if (this.game.invalid(position) || this.game.piece(position)) {
          break;
        }
        moves.push(position);
      }
      for (_j = 0, _len1 = capture_matrix.length; _j < _len1; _j++) {
        pos = capture_matrix[_j];
        position = {
          x: this.x + pos[0],
          y: this.y + pos[1],
          capture: true
        };
        if (this.game.invalid(position)) {
          continue;
        }
        if (!(this.game.piece(position) && this.game.piece(position).color !== this.color)) {
          continue;
        }
        moves.push(position);
      }
      if (filter_checks) {
        moves = (function() {
          var _k, _len2, _ref, _results;
          _results = [];
          for (_k = 0, _len2 = moves.length; _k < _len2; _k++) {
            move = moves[_k];
            if (_ref = this.color, __indexOf.call(this.game.check_exists(this, move), _ref) < 0) {
              _results.push(move);
            }
          }
          return _results;
        }).call(this);
      }
      return moves;
    };

    Pawn.prototype.post_move = function() {
      if (this.y !== 3.5 + 3.5 * this.direction) {
        return;
      }
      this.game.promote(this);
      return this.game.active = false;
    };

    Pawn.prototype.promote = function(piece) {
      return this.dom_object.fadeOut((function(_this) {
        return function() {
          var promoted;
          _this.game.remove(_this);
          promoted = new piece(_this.dom_object, _this.game, _this.color);
          _this.game.add(promoted);
          return promoted.dom_object.removeClass().addClass(promoted["class"]()).html(promoted.html()).fadeIn(function() {
            _this.game.active = true;
            _this.game.promotion = false;
            return _this.deselect();
          });
        };
      })(this));
    };

    return Pawn;

  })(Piece);

  Bishop = (function(_super) {
    __extends(Bishop, _super);

    function Bishop() {
      return Bishop.__super__.constructor.apply(this, arguments);
    }

    Bishop.move_matrix = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

    Bishop.range = 8;

    Bishop.html_code = "&#9821";

    return Bishop;

  })(Piece);

  Knight = (function(_super) {
    __extends(Knight, _super);

    function Knight() {
      return Knight.__super__.constructor.apply(this, arguments);
    }

    Knight.move_matrix = [[1, 2], [2, 1], [-1, 2], [-2, 1], [1, -2], [2, -1], [-1, -2], [-2, -1]];

    Knight.range = 1;

    Knight.html_code = "&#9822";

    return Knight;

  })(Piece);

  Rook = (function(_super) {
    __extends(Rook, _super);

    function Rook() {
      return Rook.__super__.constructor.apply(this, arguments);
    }

    Rook.move_matrix = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    Rook.range = 8;

    Rook.html_code = "&#9820";

    return Rook;

  })(Piece);

  King = (function(_super) {
    __extends(King, _super);

    function King() {
      return King.__super__.constructor.apply(this, arguments);
    }

    King.move_matrix = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];

    King.range = 1;

    King.html_code = "&#9818";

    King.prototype.possible_moves = function() {
      var moves, obstacles, range, rook, rook_x, x, _i, _len, _ref;
      moves = King.__super__.possible_moves.apply(this, arguments);
      if (this.touched) {
        return moves;
      }
      _ref = [7, 0];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rook_x = _ref[_i];
        rook = this.game.piece({
          x: rook_x,
          y: this.y
        });
        if (!rook) {
          continue;
        }
        range = rook_x === 7 ? [5, 6] : [1, 2, 3];
        obstacles = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = range.length; _j < _len1; _j++) {
            x = range[_j];
            if (this.game.piece({
              x: x,
              y: this.y
            }) || this.game.under_attack({
              x: x,
              y: this.y
            })) {
              _results.push(this.game.piece({
                x: x,
                y: this.y
              }));
            }
          }
          return _results;
        }).call(this);
        if (!obstacles.length && !rook.touched) {
          moves.push({
            x: range[1],
            y: this.y,
            castle: rook
          });
        }
      }
      return moves;
    };

    return King;

  })(Piece);

  Queen = (function(_super) {
    __extends(Queen, _super);

    function Queen() {
      return Queen.__super__.constructor.apply(this, arguments);
    }

    Queen.move_matrix = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];

    Queen.range = 8;

    Queen.html_code = "&#9819";

    return Queen;

  })(Piece);

  pieces = {
    'pawn': Pawn,
    'bishop': Bishop,
    'knight': Knight,
    'rook': Rook,
    'queen': Queen,
    'king': King
  };

  enableDrag = function() {
    var current_orientation, drag_start, orientation;
    drag_start = null;
    orientation = null;
    current_orientation = null;
    game.dom.on("mousedown", function(e) {
      drag_start = [e.pageX, e.pageY];
      return orientation = game.orientation;
    });
    return $(document).on("mousemove", function(e) {
      var offset;
      if (!drag_start) {
        return;
      }
      offset = [e.pageX - drag_start[0], e.pageY - drag_start[1]];
      game.orientation = {
        'x': (orientation.x - offset[1]) % 360,
        'y': (orientation.y + offset[0]) % 360,
        'z': orientation.z
      };
      return game.draw();
    }).on("mouseup", function() {
      return drag_start = null;
    });
  };

  $(function() {
    var intro;
    game = new Chess($("#game"), {
      "white": AIPlayer,
      "black": AIPlayer
    });
    game.orientation.z = 180;
    intro = setInterval((function(_this) {
      return function() {
        game.orientation.z = game.orientation.z % 360 + .4;
        if (game.orientation.x < 60) {
          game.orientation.x += .1;
        }
        if (game.orientation.x > 20 && !$("#menu").hasClass("active")) {
          $("#menu").addClass("active transition");
        }
        return game.draw();
      };
    })(this), 30);
    game.start();
    $(document).on("click", function(e) {
      if (e.originalEvent) {
        return $('#menu').addClass("active").removeClass("transition");
      }
    });
    return $("#menu .start").on("click", function() {
      $(this).parent().removeClass("transition").fadeOut();
      clearInterval(intro);
      game.active = false;
      game = new Chess($("#game"), {
        "white": HumanPlayer,
        "black": AIPlayer
      });
      game.animate(0, 0, 0);
      game.start();
      return enableDrag();
    });
  });

}).call(this);
