// Generated by CoffeeScript 1.7.1
(function() {
  var Bishop, Chess, King, Knight, Pawn, Piece, Queen, Rook, current_orientation, em_value, game, orientation, pieces,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  em_value = 64;

  Chess = (function() {
    Chess.players = ['white', 'black'];

    function Chess(board) {
      var x, y;
      this.board = board;
      this.moves = [];
      this.en_passant = false;
      this.promotion = false;
      this.active = false;
      this.player = null;
      this.board = (function() {
        var _i, _results;
        _results = [];
        for (x = _i = 0; _i <= 7; x = ++_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (y = _j = 0; _j <= 7; y = ++_j) {
              _results1.push(null);
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    Chess.prototype.add = function(piece) {
      return this.board[piece.x][piece.y] = piece;
    };

    Chess.prototype.draw = function() {
      return $("#" + this.player).addClass("active").siblings().removeClass("active");
    };

    Chess.prototype.invalid = function(position) {
      return position.x < 0 || position.y < 0 || position.x >= this.board.length || position.y >= this.board.length;
    };

    Chess.prototype.next_turn = function() {
      this.player = this.player === 'white' ? 'black' : 'white';
      return this.draw();
    };

    Chess.prototype.piece = function(position) {
      if (this.en_passant && this.en_passant.position.x === position.x && this.en_passant.position.y === position.y) {
        return this.en_passant.piece;
      }
      return this.board[position.x][position.y];
    };

    Chess.prototype.promote = function(pawn) {
      $(".promotion").show();
      return $(".promotion span").on("click", function() {
        pawn.promote(pieces[$(this).attr("class")]);
        return $(this).parent().fadeOut();
      });
    };

    Chess.prototype.record = function(piece, new_position) {
      return this.moves.push([
        piece, {
          x: piece.x,
          y: piece.y
        }, new_position
      ]);
    };

    Chess.prototype.remove = function(piece) {
      return this.board[piece.x][piece.y] = null;
    };

    Chess.prototype.start = function() {
      this.active = true;
      return this.next_turn();
    };

    Chess.prototype.under_attack = function(position) {
      return false;
    };

    return Chess;

  })();

  Piece = (function() {
    function Piece(dom_object, color, position, parent) {
      this.dom_object = dom_object;
      this.color = color;
      this.parent = parent;
      if (position) {
        this.x = position.x;
        this.y = position.y;
      } else {
        this.get_position(this.dom_object);
      }
      this.direction = this.color === 'black' ? 1 : -1;
      if (this.parent && this.dom_object) {
        this.dom_object.on("click", $.proxy(this.parent.make_move, this.parent, position));
      } else if (this.dom_object) {
        this.dom_object.on("click", $.proxy(this.select, this));
      }
      this.touched = false;
    }

    Piece.prototype["class"] = function() {
      return this.constructor.name.toLowerCase();
    };

    Piece.prototype.deselect = function() {
      $('#pieces span').removeClass("selected");
      $("#possible_moves").empty();
      return game.next_turn();
    };

    Piece.prototype.draw = function(fluid) {
      if (fluid) {
        return this.dom_object.animate({
          left: this.x + "em",
          top: this.y + "em"
        });
      } else {
        return this.dom_object.css({
          left: this.x + "em",
          top: this.y + "em"
        });
      }
    };

    Piece.prototype.get_position = function(dom_object) {
      if (this.dom_object.css("left").indexOf("em") !== -1) {
        this.x = Math.round(this.dom_object.css("left").replace(/em/, ""));
        this.y = Math.round(this.dom_object.css("top").replace(/em/, ""));
      } else {
        this.x = Math.round(this.dom_object.css("left").replace(/px/, "") / em_value);
        this.y = Math.round(this.dom_object.css("top").replace(/px/, "") / em_value);
      }
      return this.draw();
    };

    Piece.prototype.html = function() {
      return this.constructor.html_code;
    };

    Piece.prototype.make_move = function(position) {
      this.move(position);
      return this.deselect();
    };

    Piece.prototype.move = function(position) {
      var captured, rook_position, _ref;
      game.remove(this);
      game.record(this, position);
      _ref = [position.x, position.y], this.x = _ref[0], this.y = _ref[1];
      if (position.capture) {
        captured = game.piece(position);
        captured.dom_object.fadeOut();
        game.remove(captured);
      }
      if (position.castle) {
        rook_position = {
          x: 4 + ((4 - position.x) / -2),
          y: position.y
        };
        position.castle.move(rook_position);
      }
      game.en_passant = position.en_passant ? {
        piece: this,
        position: position.en_passant
      } : false;
      game.add(this);
      this.touched = true;
      this.draw(true);
      this.post_move();
      return game.draw();
    };

    Piece.prototype.position = function() {
      return {
        x: this.x,
        y: this.y
      };
    };

    Piece.prototype.possible_moves = function() {
      var moves, n, pos, position, _i, _j, _len, _ref, _ref1;
      moves = [];
      _ref = this.constructor.move_matrix;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        for (n = _j = 1, _ref1 = this.constructor.range; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; n = 1 <= _ref1 ? ++_j : --_j) {
          position = {
            x: this.x + pos[0] * n,
            y: this.y + pos[1] * n
          };
          if (game.invalid(position)) {
            break;
          }
          if (game.piece(position)) {
            if (game.piece(position).color !== this.color) {
              position.capture = true;
              moves.push(position);
            }
            break;
          }
          moves.push(position);
        }
      }
      return moves;
    };

    Piece.prototype.post_move = function() {};

    Piece.prototype.select = function() {
      var ghost, ghost_dom, move, _i, _len, _ref, _results;
      if (this.color !== game.player || !game.active) {
        return;
      }
      $('#pieces span').removeClass("selected");
      this.dom_object.addClass("selected");
      $("#possible_moves").empty();
      _ref = this.possible_moves();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        move = _ref[_i];
        ghost_dom = this.dom_object.clone().removeClass();
        ghost = new this.constructor(ghost_dom, this.color, move, this);
        ghost.draw();
        if (move.capture) {
          ghost_dom.text("").addClass("capture");
        }
        _results.push($("#possible_moves").append(ghost_dom));
      }
      return _results;
    };

    return Piece;

  })();

  Pawn = (function(_super) {
    __extends(Pawn, _super);

    function Pawn() {
      return Pawn.__super__.constructor.apply(this, arguments);
    }

    Pawn.html_code = "&#9823";

    Pawn.prototype.possible_moves = function() {
      var capture_matrix, move_matrix, moves, pos, position, _i, _j, _len, _len1;
      moves = [];
      move_matrix = [[0, this.direction]];
      capture_matrix = [[-1, this.direction], [1, this.direction]];
      if (this.y === 3.5 - 2.5 * this.direction) {
        move_matrix.push([0, this.direction * 2]);
      }
      for (_i = 0, _len = move_matrix.length; _i < _len; _i++) {
        pos = move_matrix[_i];
        position = {
          x: this.x + pos[0],
          y: this.y + pos[1]
        };
        if (Math.abs(pos[1]) === 2) {
          position.en_passant = {
            x: this.x,
            y: this.y + pos[1] / 2,
            'capture': true
          };
        }
        if (game.invalid(position) || game.piece(position)) {
          break;
        }
        moves.push(position);
      }
      for (_j = 0, _len1 = capture_matrix.length; _j < _len1; _j++) {
        pos = capture_matrix[_j];
        position = {
          x: this.x + pos[0],
          y: this.y + pos[1],
          capture: true
        };
        if (game.invalid(position)) {
          continue;
        }
        if (!(game.piece(position) && game.piece(position).color !== this.color)) {
          continue;
        }
        moves.push(position);
      }
      return moves;
    };

    Pawn.prototype.post_move = function() {
      if (this.y !== 3.5 + 3.5 * this.direction) {
        return;
      }
      game.promote(this);
      return game.active = false;
    };

    Pawn.prototype.promote = function(piece) {
      var pawn;
      pawn = this;
      return this.dom_object.fadeOut(function() {
        var promoted;
        game.remove(pawn);
        promoted = new piece(pawn.dom_object, pawn.color);
        game.add(promoted);
        console.log(promoted);
        console.log(promoted.html());
        promoted.dom_object.removeClass().addClass(promoted["class"]()).html(promoted.html()).fadeIn();
        return game.active = true;
      });
    };

    return Pawn;

  })(Piece);

  Bishop = (function(_super) {
    __extends(Bishop, _super);

    function Bishop() {
      return Bishop.__super__.constructor.apply(this, arguments);
    }

    Bishop.move_matrix = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

    Bishop.range = 8;

    Bishop.html_code = "&#9821";

    return Bishop;

  })(Piece);

  Knight = (function(_super) {
    __extends(Knight, _super);

    function Knight() {
      return Knight.__super__.constructor.apply(this, arguments);
    }

    Knight.move_matrix = [[1, 2], [2, 1], [-1, 2], [-2, 1], [1, -2], [2, -1], [-1, -2], [-2, -1]];

    Knight.range = 1;

    Knight.html_code = "&#9822";

    return Knight;

  })(Piece);

  Rook = (function(_super) {
    __extends(Rook, _super);

    function Rook() {
      return Rook.__super__.constructor.apply(this, arguments);
    }

    Rook.move_matrix = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    Rook.range = 8;

    Rook.html_code = "&#9820";

    return Rook;

  })(Piece);

  King = (function(_super) {
    __extends(King, _super);

    function King() {
      return King.__super__.constructor.apply(this, arguments);
    }

    King.move_matrix = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];

    King.range = 1;

    King.html_code = "&#9818";

    King.prototype.possible_moves = function() {
      var moves, obstacles, range, rook, rook_x, x, _i, _len, _ref;
      moves = King.__super__.possible_moves.apply(this, arguments);
      if (this.touched) {
        return moves;
      }
      _ref = [7, 0];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rook_x = _ref[_i];
        rook = game.piece({
          x: rook_x,
          y: this.y
        });
        range = rook_x === 7 ? [5, 6] : [1, 2, 3];
        obstacles = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = range.length; _j < _len1; _j++) {
            x = range[_j];
            if (game.piece({
              x: x,
              y: this.y
            }) || game.under_attack({
              x: x,
              y: this.y
            })) {
              _results.push(game.piece({
                x: x,
                y: this.y
              }));
            }
          }
          return _results;
        }).call(this);
        if (!obstacles.length && !rook.touched) {
          moves.push({
            x: range[1],
            y: this.y,
            castle: rook
          });
        }
      }
      return moves;
    };

    return King;

  })(Piece);

  Queen = (function(_super) {
    __extends(Queen, _super);

    function Queen() {
      return Queen.__super__.constructor.apply(this, arguments);
    }

    Queen.move_matrix = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];

    Queen.range = 8;

    Queen.html_code = "&#9819";

    return Queen;

  })(Piece);

  game = new Chess;

  pieces = {
    'pawn': Pawn,
    'bishop': Bishop,
    'knight': Knight,
    'rook': Rook,
    'queen': Queen,
    'king': King
  };

  orientation = {
    x: 55,
    y: -7,
    z: 21
  };

  current_orientation = {
    x: 0,
    y: 0,
    z: 0
  };

  $(function() {
    var drag_start, game_dom;
    game_dom = $("#game");
    if (!$("#possible_moves").length) {
      game_dom.append("<div id=\"possible_moves\"></div>");
    }
    $("#pieces span").each(function() {
      var piece;
      piece = new pieces[$(this).attr("class")]($(this), $(this).parent().attr('id'));
      return game.add(piece);
    });
    game.start();
    drag_start = null;
    game_dom.on("mousedown", function(e) {
      return drag_start = [e.pageX, e.pageY];
    });
    return $(document).on("mousemove", function(e) {
      var offset;
      if (!drag_start) {
        return;
      }
      offset = [e.pageX - drag_start[0], e.pageY - drag_start[1]];
      current_orientation = {
        'x': (orientation.x - offset[1]) % 360,
        'y': (orientation.y + offset[0]) % 360,
        'z': orientation.z
      };
      return game_dom.css({
        '-webkit-transform': 'rotateX(' + current_orientation.x + 'deg) rotateZ(' + current_orientation.z + 'deg) rotateY(' + current_orientation.y + 'deg)'
      });
    }).on("mouseup", function() {
      drag_start = null;
      return orientation = current_orientation;
    });
  });

}).call(this);
